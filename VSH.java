import java.util.Random;

/**
 *  A Visualisation Tool for 
 *  Selection Hyper-Heuristics                                    <br>   
 *  															  <br>
 *  http://code.google.com/p/vch/   							  <br>
 *  															  <br>
 *  Module:                  G52GRP, University of Nottingham     <br>
 *  															  <br>
 *  Group:        gp09-exo    						  			  <br>
 * @author 	   	Lao Jingqi (jxl29u)
 * @author	   	Zhang Chao (cxz09u)
 * @author		Thomas Barton (txb18u)
 * @author		Ben Jenkinson (bxj08u)
 * @author	   	Alexander Jermstad (asj08u) 				      <br>	
 * 																  <br>
 *   main program
 * 			
 */


public class VSH {
	/**
	 *  The instance of hyperHeuristic
	 */
	HyperHeuristic hyperHeuristic;
	/**
	 *  The instance of VSHMainFrame
	 */
	VSHMainFrame frame;
	/**
	 *  The instance of HyperHeuristicBuilder
	 */
	HyperHeuristicBuilder HHBuilder;
	/**
	 *  The instance of HyperHeuristicDirector
	 */
	HyperHeuristicDirector HHDirector;
	/**
	 *  The random instance 
	 */
	Random random = new Random();
	/**
	 *  A 15 bit integer to store the candidate solution
	 */
	int candidateSolution [] = new int[HyperHeuristic.DIGIT_NUM];
	/**
	 *  A 15 bit integer to store the new solution
	 */
	int newSolution[] = new int[candidateSolution.length];
	/**
	 *  It always points to the low level instance
	 */
	LowLevelHeuristic lowLevelHeuristic;
	/**
	 *  Count the number of iterations
	 */
	int count = 0;
	/**
	 *  The two-dimensional integer to store the previous new solution generated by  hyper-heuristic
	 */
	int [][] history = new int[1000][15];
	/**
	 *  The delay time
	 */
	int sleepTime = 10;
	/**
	 *  Initial the name of benchmark function of  hyper heuristic
	 */
	String functionNmae = "f(x)=x^2";
	/**
	 * Initial the name of acceptance method
	 */
	String acceptanceMethodName = "Improving or Equal";
	/**
	 *  Initial the name of heuristic selection name
	 */
	String heuristicSelectionName = "Simple Random";
	/**
	 *  Initial the names of low level heuristic 
	 */
	String [] lowLevelHeuristicNames = {"Reverse","Inverse","Shift","Flip One Bit","Steepest Gradient"};
	
	/**
	 *  main method 
	 * @param args
	 */
	public static void main(String[] args){

		new VSH().start();
	}
	
	/**
	 *  the method to start the software
	 */
	void start(){
		frame =new VSHMainFrame("VSH",this);
		for(;;){
			if(!frame.start){
				frame.stop();				
			}
			count++;
			calculate();
			
			while(!frame.panel.m_panel.animationPanel.animationFinished){
				if(frame.pause){
					frame.stop();	
				}
				if(frame.stop){
					frame.panel.m_panel.animationPanel.reset();
					break;
				}
				exhibition();
				try {
					Thread.sleep(sleepTime);
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
			acceptanceCheck();
		}
	}
	
	/**
	 *  the method to build the hyper heuristic
	 */
	void buildHyperHeuristic(){
<<<<<<< .mine
=======

		// Print out all the low-level heuristics.
		//System.Out.println("Available LowLevelHeuristics:");
		for(int i=0;i<lowLevelHeuristicNames.length;i++){
			//System.Out.println( "  " + lowLevelHeuristicNames[i] );
		}

>>>>>>> .r120
		HHBuilder= new HyperHeuristicBuilder();
		HHDirector = new HyperHeuristicDirector(HHBuilder); 
		HHDirector.construct(functionNmae, acceptanceMethodName, lowLevelHeuristicNames, heuristicSelectionName);
		hyperHeuristic = HHBuilder.GetHyperHeuristic();
		for(int i =0; i<candidateSolution.length;i++){
			candidateSolution[i] = random.nextInt(2);
			history[0][i]=candidateSolution[i];
		}
		
		
	}
	
	/**
	 *  the method to do one hyper heuristic calculation 
	 */
	void calculate(){
		lowLevelHeuristic = hyperHeuristic.heuristicsSelection.selectLowLevelHeuristic(candidateSolution);
<<<<<<< .mine
=======

		//System.Out.println( "calculate->" + lowLevelHeuristic.getName() );

>>>>>>> .r120
		if(hyperHeuristic.heuristicsSelection.getName().equals("Greedy Random")){
			newSolution = ((GreedyRandom)hyperHeuristic.heuristicsSelection).optimumSolution;
		}else{
			newSolution= lowLevelHeuristic.generateNewSolution(candidateSolution);
			
		}
		for(int i=0;i<newSolution.length;i++){
			history[count][i] = newSolution[i];
		}
		frame.panel.m_panel.animationPanel.animationFinished = false;
		
	}
	
	/**
	 * the method to exhibition how the hyper heuristic works
	 */
	void exhibition(){
		frame.panel.m_panel.animationPanel.repaint();
	}
	
	/**
	 *  the method to check if accept new solution
	 */
	void acceptanceCheck(){
		if(hyperHeuristic.acceptanceMethod.checkIfAcceptance(candidateSolution, newSolution)){
			candidateSolution = newSolution;
			if(hyperHeuristic.heuristicsSelection.getName().equals("Reinforcement Learning"))
				((ReinforcementLearning)hyperHeuristic.heuristicsSelection).incrementScore();
		}else{
			if(hyperHeuristic.heuristicsSelection.getName().equals("Reinforcement Learning"))
				((ReinforcementLearning)hyperHeuristic.heuristicsSelection).decrementScore();
		}
	}
}


